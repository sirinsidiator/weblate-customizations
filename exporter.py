import re

from django.utils.translation import gettext_lazy as _

from translate.storage import base

from weblate.formats.exporters import MonolingualExporter
from weblate.formats.ttkit import TTKitFormat

class LibGetTextUnit(base.TranslationUnit):

    def __init__(self, source=None):
        super().__init__(source)
        self.source = source or ""
        self.target = ""

    def fromdict(self, cedict, encoding="utf-8"):
        self.source = cedict.get("source")
        self.target = cedict.get("target")

    def todict(self, **kwargs):
        return {
            "source": self.source,
            "target": self.target,
        }

    def __str__(self):
        return str(self.todict())

WARNING_LINE = '-- This file is automatically generated. DO NOT EDIT IT DIRECTLY!'
COMMENT_LINE_TEMPLATE = '-- Visit {} to update translations.'
COMMENT_LINE_PREFIX = '-- Visit http'
SETTEXT_LINE_TEMPLATE = 'local settext = LibGetText("{}").settext'
SETTEXT_LINE_PREFIX = 'local settext = LibGetText("'
TEXT_LINE_TEMPLATE = 'settext("{}", "{}")'
TEXT_LINE_PREFIX = 'settext("'

class LibGetTextFile(base.TranslationStore):
    """This class represents a .lua file for LibGetText. 
    The format only contains source and target values
    """

    UnitClass = LibGetTextUnit
    Name = "LibGetText Lua"
    Mimetypes = ["text/x-lua"]
    Extensions = ["lua"]

    def __init__(self, inputfile=None, fieldnames=None, encoding="auto"):
        super().__init__(encoding=encoding)
        self.fieldnames = [
            "source",
            "target",
            "id",
        ]
        self.filename = getattr(inputfile, "name", "")
        self.dialect = "default"
        if inputfile is not None:
            luasrc = inputfile.read()
            inputfile.close()
            self.parse(luasrc)

    def updateheader(self, url, project_name):
        self.url = url
        self.project_name = project_name

    def parse(self, luasrc):
        lines = luasrc.splitlines()
        warning = lines.pop(0)
        comment = lines.pop(0)
        settext = lines.pop(0)
        if warning != WARNING_LINE or not comment.startswith(COMMENT_LINE_PREFIX) or not settext.startswith(SETTEXT_LINE_PREFIX):
            raise base.ParseError(ValueError("Invalid LibGetText Lua file"))

        p = re.compile(r'settext\("(?P<source>.+)", "(?P<target>.+)"\)')
        for line in lines:
            if not line.startswith(TEXT_LINE_PREFIX):
                raise base.ParseError(ValueError("Invalid LibGetText Lua file"))
            unit = self.UnitClass()
            m = p.match(line)
            unit.fromdict(m.groupdict())
            self.addunit(unit)

    def serialize(self, out):
        """Write to file"""
        source = self.getoutput()
        if isinstance(source, str):
            # Python 3
            out.write(source.encode('utf-8'))
        else:
            out.write(source)

    def getoutput(self):
        lines = [
            WARNING_LINE,
            COMMENT_LINE_TEMPLATE.format(self.url),
            SETTEXT_LINE_TEMPLATE.format(self.project_name),
        ]
        for ce in self.units:
            values = ce.todict()
            if values["target"] != "":
                line = TEXT_LINE_TEMPLATE.format(values["source"], values["target"])
                lines.append(line)
        return "\n".join(lines)

class LibGetTextExporter(MonolingualExporter):
    storage_class = LibGetTextFile
    name = "libgettext"
    content_type = "text/x-lua"
    extension = "lua"
    verbose = _("LibGetText")

    def get_storage(self):
        store = super().get_storage()
        store.updateheader(self.url, self.project.name)
        return store

class LibGetTextFormat(TTKitFormat):
    name = _("LibGetText file")
    format_id = "libgettext"
    loader = LibGetTextFile
    monolingual = True
    unit_class = LibGetTextUnit